#!/usr/bin/env bash
set -Eeuo pipefail
trap 'rc=$?; echo -e "\e[31m[WRAPPER-ERROR]\e[0m $0:$LINENO: \"$BASH_COMMAND\" exited with $rc" >&2' ERR
# set -x  # optional

this_script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- import external binaries in PATH
export PATH=${this_script_dir}/include_bins/shunit2:$PATH

if ! command -v shunit2 >/dev/null; then
    printf "\033[0;32m[ERROR]\033[0m cannot find or exec shunit2"
    exit 1
fi

# defaults
dry_run=0
filter=""
workflow="install"
run_test_only=0
run_script_only=0

# --- tiny logging -------------------------------------------------------------
log() { printf "%s\n" "$*"; }
log_dry() { printf "\033[0;32m[DRY_RUN]\033[0m %s\n" "$*"; }



usage() {
  cat <<EOF
Usage: $0 [options]

Options:
  -d, --dry-run            Print actions without executing.
  -w, --workflow NAME      Workflow name (default: install).
  -f, --filter LIST        Comma-separated list of script names to run (exact match).
  -t, --run-test-only      Run tests only.
  -s, --run-script-only    Run scripts only.
  -h, --help               Show this help.
EOF
}

# --- args --------------------------------------------------------------------
while [[ $# -gt 0 ]]; do
  case "$1" in
    -d|--dry-run)         dry_run=1; shift ;;
    -f|--filter)          filter="${2:-}"; shift 2 ;;
    -t|--run-test-only)   run_test_only=1; shift ;;
    -s|--run-script-only) run_script_only=1; shift ;;
    -w|--workflow)        workflow="${2:-}"; shift 2 ;;
    -h|--help)            usage; exit 0 ;;
    --)                   shift; break ;;
    *)                    echo "Unknown option: $1"; usage; exit 2 ;;
  esac
done

# mutually exclusive
if [[ $run_test_only -eq 1 && $run_script_only -eq 1 ]]; then
  echo "Choose only one of --run-test-only or --run-script-only." >&2
  exit 2
fi

workflow_file="${this_script_dir}/provisions/workflows/${workflow}.sh"
if [[ ! -f "$workflow_file" ]]; then
  echo "Workflow file not found: $workflow_file" >&2
  exit 1
fi

# --- filter helper ------------------------------------------------------------
IFS=',' read -r -a FILTER_LIST <<< "$filter"
in_filter() {
  local name="$1"
  # no filter -> allow all
  if [[ ${#FILTER_LIST[@]} -eq 0 || -z "${FILTER_LIST[*]// }" ]]; then
    return 0
  fi
  local f
  for f in "${FILTER_LIST[@]}"; do
    [[ "$name" == "$f" ]] && return 0
  done
  return 1
}

# --- runner helpers -----------------------------------------------------------
run_bash() {
  local path="$1"
  if [[ $dry_run -eq 1 ]]; then
    printf "\033[0;32m[DRY_RUN]\033[0m bash %s\n" "$path"; return 0
  fi
  bash -Eeuo pipefail "$path"
}

run_bash.DEPRECATED() {
  # run a file via bash (no chmod), honoring dry-run, de-duplicating output
  local path="$1"
  if [[ $dry_run -eq 1 ]]; then
    log_dry "bash $path"
    return 0
  fi
  # Deduplicate only consecutive identical lines while preserving exit code
  set +e
  bash "$path" 2>&1 | awk 'NR==1{prev=$0; print; next} { if ($0!=prev) print; prev=$0 }'
  local status=${PIPESTATUS[0]}
  set -e
  return $status
}

# --- main loop ---------------------------------------------------------------
# read non-empty, non-comment lines (already trims & skips with awk)
while IFS= read -r script_name; do
  [[ -z "$script_name" || "$script_name" =~ ^# ]] && continue
  in_filter "$script_name" || continue

  script_path="${this_script_dir}/provisions/${script_name}"
#  test_path="${this_script_dir}/provisions/tests/test_$(basename "$script_name" .sh).bats"
  test_path="${this_script_dir}/provisions/tests/test_${script_name}"

  do_run_script=1
  do_run_test=1
  [[ $run_test_only -eq 1 ]]   && do_run_script=0
  [[ $run_script_only -eq 1 ]] && do_run_test=0

  # run script (silent skip if missing)
  if [[ $do_run_script -eq 1 && -f "$script_path" ]]; then
    run_bash "$script_path"
  fi

  # run test (silent skip if missing)
  if [[ $do_run_test -eq 1 && -f "$test_path" ]]; then
    run_bash "$test_path"
  fi

done < <(awk 'NF && $1 !~ /^#/' "$workflow_file")

exit 0

